%% 
%% Copyright 2007, 2008, 2009 Elsevier Ltd
%% 
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%% 
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%% SP 2008/03/01

%\documentclass[preprint,12pt]{elsarticle}
 \documentclass{elsarticle}
%\documentclass[3p,12pt,authoryear]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times,authoryear]{elsarticle}
%% \documentclass[final,1p,times,twocolumn,authoryear]{elsarticle}
%% \documentclass[final,3p,times,authoryear]{elsarticle}
%% \documentclass[final,3p,times,twocolumn,authoryear]{elsarticle}
%% \documentclass[final,5p,times,authoryear]{elsarticle}
%% \documentclass[final,5p,times,twocolumn,authoryear]{elsarticle}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor   = red %Colour of citations
}

%% For including figures, graphicx.sty has been loaded in
%% elsarticle.cls. If you prefer to use the old commands
%% please give \usepackage{epsfig}
\usepackage{subfig}

%tables
\usepackage{booktabs}
\usepackage[vlined, linesnumbered, ruled]{algorithm2e}
%\usepackage{float}
%\newfloat{algorithm}{t}{lop}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{esint}

%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

% just for our notes
\usepackage[usenames,dvipsnames]{color}   %colors


\journal{Applied Mathematics and Computation}

%commands:
%\newcommand{\defref}[1]{\hyperref[#1]{Def.~\ref{#1}}}
\newcommand{\prob}[1]{Problem~{#1}}
\newcommand{\fig}[1]{\hyperref[#1]{Figure \ref{#1}}}
\newcommand{\figpath}{figures/}

%math:
\def\vc#1{\mathbf{\boldsymbol{#1}}}     % vector
\def\abs#1{\left|#1\right|}
\def\avg#1{\langle#1\rangle}
\def\d{\mathrm{d}}
\def\norm#1{\| #1 \|}
\def\abs#1{| #1 |}
\def\prtl{\partial}
\newcommand{\dd}{\; \mathrm{d}}
\newcommand{\R}{\mathbf{R}}
\newcommand{\bx}{\vc{x}}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}


\newcommand{\noteJB}[1]{{\color{Blue} \textbf{JB: } \textit{#1}}}
\newcommand{\notePE}[1]{{\color{Orange} \textbf{PE: } \textit{#1}}}
\newcommand{\plucker}{Pl\"{u}cker }

\newdefinition{mdef}{Definition}%[section]

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Intersection of non-matching grids of different dimensions}
% Self-intersection of non-matching grid of mixed dimensions

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \address[label1]{}
%% \address[label2]{}

\author[adr]{Jan B{\v r}ezina\corref{cor1}}
\ead{jan.brezina@tul.cz}
\cortext[cor1]{Corresponding author.}

\author[adr]{Pavel Exner}
\ead{pavel.exner@tul.cz}
%\ead[url]{https://github.com/Paulie14/xfem\_project}

\address[adr]{Technical University of Liberec, Studentsk{\' a} 1402/2, 461 17 Liberec 1, Czech Republic}


\begin{abstract}
TODO: An abstract.
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
non-matching gird \sep 
intersections \sep
mixed-dimensional mesh \sep
\plucker coordinates


%% PACS codes here, in the form: \PACS code \sep code
%\PACS 02.60.Lj \sep        %Ordinary and partial differential equations; boundary value problems
%\PACS 02.60.Jh             %Numerical differentiation and integration

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
%\MSC[2010] 65N30 \sep %    Finite elements, Rayleigh-Ritz and Galerkin methods, finite methods
%\MSC[2010] 35J05  %    Laplacian operator, reduced wave equation (Helmholtz equation), Poisson equation

\end{keyword}

\end{frontmatter}

%% \linenumbers

%% main text
\section{Introduction}
Structure of introduction:

- motivation for computing mesh intersections, other applications
- basic overview of existing work, approaches
- our contribution
    - new algorithms for element intersectins based on Pl\"ucker coordinates
    - improvement of the front tracking algorithm

\cite{sukumar_extended_2000} - Use {\emph geometric predicates} incircle and orientation. Use mesh of bounding boxes to search for intersection candidates. 
Only use point queries for all vertices of triangle/tetrahedron. Use compatible partitioning of elements by the crack elements.

\cite{massing_efficient_2013} - Implementation of the Nitche method in Fenics. They need 2d-3d intersections, but only for distribution od quadrature points. 
So they do not store whole intersection data, but only the quad points. The boundary of one domain is partitioned into intersections with elements of the other domain.
Use {\\emph collision relations} ( pairs of faces of boundary and elmements of the background mesh) and {\emph collision maps} 
( map face to all intersections and background element to all intersections, can be constructed from the collision relation), They cite books from computer graphics ..
Mention geometric predicates. Present algorithms for:  find intersection candidates, comput intersections, integrate over complex domains.

\cite{elsheikh_reliable_2012} Claim to provide robust algorithm covering all tiangle-trinagle degenerate cases. Basic idea is the same as our: use some tree 
(Binary SPace Tree) structure to find initial point on intersection curve and trace the curve in both directions. Quite clever data structure for the mesh. Adaptive precision 
geometric predicates. Store topological information about the intersection points (point on triangle, edge, vertex). Resolve various degenerate cases, 
dicuss mesh optimization after subdivision.


\cite{gander_algorithm_2013} Full algorithm for 2d=3D called PANG. Implemented in DUNE in 2010 (Bastian). Other software (Hecht, MpCCI). 
Triangle-Triangle and Tetra-Triangle intersections done similarly as in aur approach: set of points including vertices and then sort them countercolckwise.
Local intersection algorithm do not provide neighbouring information so the traversal algorithm do not use it.

Review of algorithms: \cite{gander_algorithm_2009}
 

\cite{boon_robust_2016} Robust discretization of porous media. Complete error analysis with mortar non-compatible case. Seems they use normal fluxes accros
fracture instead of pressure traces. This allows conforming discretization and error results.


\cite{bournival_mesh-geometry_2008} Application of mixed-dimensional approach in mechanics. Beam and shell elements ...

\cite{reichenberger_mixed-dimensional_2006} Finite volume method, fully implicit two phase flow. Cite usage of FRAC3D generator. 

\cite{sladkova_bakalarka} Space-time DG with adaptive mesh, need integration of product of functions on different meshes (in 2D). An algorithm 
for computing triangle-triangle intersections in 2D.

\cite{pichot_generalized_2012} DFN + MHFEM. Mortar method for intersections. Focused on formulation not on intersections. 

\cite{flemisch_non-matching_2012} (Barbara) Mortad, non=matching, acustics. Theory, structured gird case. No complex intersections.

\cite{mustapha_hybrid_2014} Patent for curiosity.

\cite{mittal_immersed_2005} Immersed boundary. ??

\cite{owen_survey_1998} ??

\cite{kuznetsov_overlapping_1998}

\cite{platis_fast_2003} Original algorithm for line-thetrahedra intersections.

\cite{haines_fast_1991} Line-convex Polyhedra intersections using generalisation of line-clipping algorithm



The initial problem that occurs when working with incompatible meshes of combined dimensions is the efficient 
computation of intersections of the mesh subdomains, in particular 1D-2D, 1D-3D, 2D-3D.
There is a piece of code in Flow123d at the moment which uses means of analytic geometry. In particular, it computes 
an intersection of a line and a plane in 3D by solving Gaussian elimination. However it is not effiecient
and it does not provide barycentric coordinates explicitly.
In this section, we present our latest work on this problematics.

The topic is studied in the bachelor and master thesis of Viktor Fri{\v s} \cite{fris_dp_2015}, who was supervised by 
Jan B{\v r}ezina.
They suggested a solution, based on \cite{yuan_efficient_2003} for the two aspects of the problem: 
\begin{enumerate}[itemsep=-3pt]
\item an efficient identification of the intersecting pairs of elements,
\item an efficient computation of the actual intersection for the single element pair.
\end{enumerate}
The algorithm is based on the methods used in the computer graphics, in particular for the task (b) \plucker
coordinates are employed to efficiently compute 1D-2D intersection in three-dimensional space.

\begin{figure}[!htb]
  \centering
  \setcounter{subfigure}{0}
  \subfloat[1D-3D]{
    \includegraphics[width=0.3\textwidth]{\figpath intersection_13.pdf} }
  \hspace{10pt}
  \subfloat[2D-3D]{
    \includegraphics[width=0.3\textwidth]{\figpath intersection_23.pdf} }
\end{figure}
      
For the 1D-3D and 2D-3D cases, the basic algorithm is applied on sides and edges of the simplices and 
all the topological information coming from the performed \plucker products is carefully collected
to obtain final intersecting object.
Further in 2D-3D case, an optimized tracing algorithm is suggested to directly obtain the correct order and 
orientation of the edges of the intersection polygon.


\section{Element Intersections}
\label{sec:elements_intersections}
In this section, we present algorithms for computing intersection of a pair of simplicial elements of a~different dimension in the 3D ambient space.
In particular we are interested in intersection of 1D-2D, 1D-3D, 2D-2D, 2D-3D simplices. In general the intersection can be a point, a line segment or a polygon.
All these three objects are represented as a vector of vertices called \emph{intersection points}. The fundamental idea is to compute intersection of 1D-2D simplices using the 
\plucker coordinates and reduce all other cases to this one. 

The intersection point data structure keeps for each of the two intersection simplices:
\notePE{Subsimplex or subelement?}
\begin{itemize}
 \item Barycentric coordinate of the intersection.
 \item Dimension of the most specific subsimplex (face, edge, vertex) where the point lies.
 \item Index of the most specific subelement.
\end{itemize}
Further, we store the sign of the permuted inner product
in order to detect various special and degenerate cases.



\subsection{\plucker Coordinates}
\plucker coordinates represent a line in 3D space.
Considering a line $p$, given by a point $\vc A$ and its directional vector $\vc{u}$, 
the \plucker coordinates of $p$ are defined as
\[ \pi_p = (\vc{u}_p, \vc{v}_p) = (\vc{u}_p, \vc{u}_p\times A). \]
Further we use a permuted inner product
\[\pi_p \odot \pi_q = \vc{u}_p\cdot \vc{v}_q + \vc{u}_q \cdot \vc{v}_p. \]

The sign of the permuted inner product gives us the relative position of the two lines, 
see \fig{fig:plucker_products}.



\begin{figure}[!htb]
  \begin{center}        
    \includegraphics[width=0.7\textwidth]{\figpath plucker_product.pdf}
%    \includegraphics{\figpath plucker_products.pdf}
  \end{center}
  \caption{Sign of the permuted inner product is related to the relative position of the two oriented lines. Dashed line symbolizes that the line is in the back, the lines intersect in the middle case.
           \notePE{circle dot permuted inner product}}
  \label{fig:plucker_products}
\end{figure}


%Notice the condition on the orientation of the triangle sides. To always satisfy it, we use a
%reference simplex, in which the numbering of nodes and sides and also the orientation is fixed.
%The barycentric coordinates of the intersection point can be computed directly from the \plucker products
%and then we can easily obtain its real coordinates (see \cite{fris_dp_2015} for derivations and details).

\subsection{Intersection Line-Triangle (1D-2D)}
\notePE{In this paragraph we investigate real lines. Trimming comes later when tolerance is denoted, see next PE note.}
Let us consider a line $p$ with parametric equation $\vc X = \vc A + t\vc u$, $t\in\R$ and a triangle given by vertices $(\vc V_0, \vc V_1, \vc V_2)$ 
with oriented sides $s_i=(V_j, V_k)$, $j=(i+1)\text{ mod }3$, $k=(i+2)\text{ mod }3$. The permuted inner products $\pi_p \odot \pi_{s_i},\, i=0,1,2$ have the same sign if and only if there
is an intersection point with the       line $p$ inside the triangle. In such a case, the inner products provides scaled barycentric coordinates of the intersection on the triangle.
In particular for the barycentric coordinate $w_i$ related to the vertex $V_i$ we have
\[
   w_i = \frac{\pi_p \odot \pi_{s_i}}{ \sum_{j=0}^{2} \pi_p \odot \pi_{s_i} }
\]
Indeed, using the barycentric coordinates the intersection point can be expressed as $\vc X = \vc V_0 + w_1 \vc s_2 - w_2 \vc s_1$.
The line $p$ have \plucker coordinates $(\vc u, \vc u \times \vc X)$ (\plucker coordinates are invariant to change of initial point). Combining these two expressions we get
\[
   \pi_p \odot \pi_{s_1} = \vc u \cdot (\vc s_1 \times V_2) + \vc s_1 \cdot ( \vc u \times [\vc V_0 + w_1\vc s_2 - w_2 \vc s_1])
   =-w_1 \vc u \cdot (\vc s_1 \times \vc s_2).
\]
Since $\vc s_0 + \vc s_1 + \vc s_2=0$ we have $ \vc s_1 \times \vc s_2 = \vc s_2 \times \vc s_0 = \vc s_0 \times \vc s_1$ and thus
\[
   \pi_p \odot \pi_{s_i} = -w_i \vc u \cdot (\vc v_1 \times \vc v_2).
\]
Having the barycentric coordinates of the intersection on the triangle we can compute also its local coordinate on $p$ from its parametric form:
\[
   X_i  = A_i + t u_i, \text{ for } i=1,2,3
\]
We use $i$ with maximal $|u_i|$ for practical computation.

Next, we shall discuss the case when some of the permuted inner products are zero. In fact, we test if any barycentric coordinate is under given tolerance 
($\abs{w_i} \le \epsilon$). Various \emph{pathological} cases are detected and further topological 
information is atached to the intersection data.  In the case of one zero coordinate (non-coplanar intersection on the edge)
or two zero coordinates (intersection in the vertex), we add the local edge index or the local vertex index to the intersection, respectively.
When all coordinates are (close to) zero, the line and the triangle are (nearly) coplanar. For every edge $s_i$ we compute
its intersection with the line segment $p$ in terms of the local coordinates $t_i$ and $t_p$. Only intersections with $t_i \in (-\epsilon, 1+\epsilon)$
are accepted, for $t_i$ close to $0$ and $1$ we append the vertex index to the intersection. Edges parallel to $p$ or lying on the $p$ are skipped.
Finally, we obtain zero, one, or two intersection points with additional topological information.


TODO:
We should distinguish "special" case and "degenerate" case. The later one is the case when line lies in the plane of the triangle. The first case should be
treated as usual only set aditional topology info about vertex or edge. The degenerate case is not necessary to investigate in the case of auxiliary
intersection only in the case of final intersection. Need to verify it since it is not the case in current code.


We distinguis two variants of the desired result: the auxiliary intersection used as subprocedure of the other intersections and the final intersection.
In the first case we just return the array of the intersection points with the line.
\notePE{In the first case, we do not trim the line (We need both IPs (if there are two), for 1D-3D). In the final case, we need to check that also $t_p \in (-\epsilon, 1+\epsilon)$. That is the current state.}
 Degenerated case of $p$ laying on the triangle edge is also detected....

Intersection with line segment ... (final 1D-2D intersection)

\subsection{Intersection Line-Teraherdon (1D-3D)}
We consider a line $p$ and a tetraherdon...
Tetrahedron has six edges, so six \plucker coordinates and inner products are computed at most. These data are
passed to the 1D-2D algorithm described above, which is applied to the every face of the tetrahedron face. 

There might be two intersection points maximally, which are finally checked that they belong o abscissas.
If the line has its boundary point inside the tetrahedron, the intersection line must be cut
and coordinates of intersection point are interpolated.
Pathologic cases are again carefully processed so we obtain the most extensive topology information we can.
See \cite{fris_dp_2015} for detailed description of all possible cases.

\subsection{Intersection Triangle-Tetrahedron (2D-3D)}
The intersection of a triangle $S_3$ and a tetrahedron $S_4$ is an $n$-side polygon, $n\le 7$. The sides of the polygon
are coincident with either sides of $S_3$ or with faces of the $S_4$. Thus each vertex of the polygon
can arise either from side-face intersection, or from edge-triangle intersection, or be a vertex of $S_3$.
So we have to compute at most 12 side-face intersections and at most 6 edge-triangle intersections. However,
to this end we only need to compute 9 \plucker coordinates (3 sides, 6 edges) and 18 permuted inner produts, one for every side-edge pair.
Computation of the intersection polygon consists of three parts: calculation of IPs on the $S_3$ boundary (Algorithm \ref{algo:colect_23_ip_triangle}),
calculation of IPs in the interior of $S_3$ (Algorithm \ref{algo:collect_23_ip_edges}), and finalize the correct order of IPs (Algorithm \ref{algo:order_23}).
Correct order of the IPs stored in the list $I$ is defined by tables $F_g(:)$ and $F_p(:)$. Every side of the intersection polygon lies either on side of $S_3$, or
on face, or on edge of $S_4$. Let us denote $M_3$ the set of sides of $S_3$ and $M_4$ the set of volume, faces, edges, and vertices of $S_4$. 
Every side of polygon that lies on $x\in M_32$ is folowed by an IP given by $F_g[x]$ and every IP $p$ is folowed by the side that lies on $F_p[p]\in M_32$. 

\begin{algorithm}
  \caption{2d-3d intersection, points on triangle boundary}
  \label{algo:colect_23_ip_triangle}

  \DontPrintSemicolon
  \SetKw{continue}{continue}
  \KwIn{input data}
  \KwOut{List of IPs on sorted output data}  
  $F_g(:)=-1$\tcp*{Unset IPs of geometric entities.} 
  $F_p(:)=-1$\tcp*{Unset geometric entities of IPs.}
    
  \For{side $i$ of $S_3$}{ 
    $L$ = intersection($i, S_4$)\;
    \lIf{ \abs{L} = 0}{\continue}
    \lIf{ \abs{L} = 1}{
        append $p$ to $J$
        \continue
    }
    \For{$p$ in $L$}{
        \lIf{$p \ne I[-1]$ }{append $p$ to $I$}
        $p$ lies on $x\in M_4$ and side $s\in M_3$\; 
        \uIf{$p$ is first in $L$}{
            $F_g[x] = p$\;
            $F_p[p] = s$\;
        }
        \Else($p$ is the last in $L$){
            $F_g[s] = p$\;
            $F_p[p] = x$\;
            \nllabel{line:back_link43}
            \lIf{$F_g[x] = -1$}{$F_g[x] = p$}\;
        }
    }
  }  
  \lIf{$I[-1] = I[0]$}{
    $F_g[F_p[I[-1]]]]=I[0]$\;
    $F_g[s_2] = I[0]$\;
    remove $I[-1]$
  }
\end{algorithm}


In Algorithm \ref{algo:colect_23_ip_triangle}, we first compute IPs
on the boundary of $S_3$ using the line-tetrahedron intersection algorithm for every side. We store intersections with just single IP ito separate list $J$
and skip filling the connection tables. This happen when the side just touch $S_4$ in edge or vertex. 
These IPs will be rediscovered again in Algorithm \ref{algo:collect_23_ip_edges} with better topological information, however
this is not the case if the touched edge $e$ of $S_4$ is coplanar with $S_3$ and the IP is inside of $e$. 
Therefore we keep a separate list of IPs to deal with this case.
For the intersection $L$ we pass through its IPs. The IP $p$ is added to the list $I$ unless the last point is the same. 
This condition is effective just for the first point of $L$ and merge IPs at the same vertex of $S_3$. If the vertex $v$ is between sides $s_1$, $s_2$, 
we effectively set $F_g[s_1] = v$, $F_g[y]=v$, $F_p[v] = s_2$. The backward temporary link on the line \ref{line:back_link43} 
is used in Algorithm \ref{algo:collect_23_ip_edges} to fix $F_p[p]$ for the second $p$ lying on an edge or a vertex of $S_4$. The condition deals with the case
when two sides intersect the same object $x\in M_4$.


\begin{algorithm}  
  \caption{2d-3d intersection, points in triangle interior}
  \label{algo:collect_23_ip_edges}
  
  \SetKw{And}{And}
  \DontPrintSemicolon
  \KwIn{$I$ with IPs on $S_3$ boundary, partialy filled $F$}
  \KwOut{all IPs in $I$, complete $F$}  
  
  \nllabel{line:12edges}
  \lFor{edge $e$ of $S_4$}{$L[e]$ = intersection($e, S_3$)} 
  \For{unmarked edge $e$ of $S_4$}{
    $p=L[e]$\;
    \uIf{ $p$ is inside of $e$}{ 
        \nllabel{line:edge_faces}        
        $(f_0,\ f_1)$ = edge faces($e$)
    } 
    \Else($p$ on the vertex $v$ of $S_4$){       
            $(f_0,\ f_1)$ = vertex faces($v$)   \tcp*{Algorithm \ref{algo:vertex_faces}}
    }    
    \uIf{ $p$ is on boundary of $S_3$ }{
         $p\in x \in M_4$; $x$ is edge or vertex 
         $q=F_g[x]$\tcp*{$q$ is already computed $p$}
         \lIf{$F_p[q]=x$}{$F_p[q]=f_1$}
         \lElse{$F_g[f_0]=q$}
         $F_g[x]=-1$\tcp*{remove the backlink}
    }
    \Else{
         append $p$ to $I$\;
         $F_g[f_0]=p$\tcp*{overwrites the backlink}
         $F_p[p]=f_1$
         mark all edges coincident with $p$
    }   
  }  
  
  \lIf{$\abs{I} < 3$}{ \return $J$}
  \lElse{ return $I$ soter according connectivity in $F_g$ and $F_p$}
\end{algorithm}

\begin{algorithm}
  \caption{2d-3d intersection, vertex faces}  
  \label{algo:vertex_faces}
  
  \SetKw{return}{return}
  \SetKw{edgefaces}{edge faces}
  \DontPrintSemicolon
  \KwIn{vertex $v$ of $S_4$, $L[:]$ intersection results for edges of $S_4$}
  \KwOut{$(x_1, x_2)$, $x_1, x_2 \in M_4$, coincident with $v$ and intersected by the plane of $S_3$}
  $e_0,\ e_1,\ e_2$ edges coincident with $v$ oriented out of $v$
  $s[i] = L[e_i]$, for $i=0,1,2$, \;
  \nllabel{line:two_degenerated}
  \uIf{$s[:]$ have 1 non-degenerate edge $e$}{
    \return pair of degenerate edges sorted according to \edgefaces($e$)    
  }
  \nllabel{line:one_degenerated}
  \uElseIf{ $s$ have 1 degenerate edge $e$}{
    $f$ is face oposite to $e$
    \uIf{other two edges $e_a$, $e_b$ have different sign}{
        $z=\edgefaces(e_a)$\;
        replace $g\in z$, $g\ne f$ with $e$
        \return $z$
    }\lElse{
        append IP of $v$ to $J$
        \return anything\;
    }
  }
  \nllabel{line:different_sign}
  \uElseIf{ $s$ have edge $e$ with sign oposite to other two}{
    \return edge faces($e$)\;
  }
  \nllabel{line:same_signs}
  \Else($s$ have all signs same){
    append IP of $v$ to $J$
    \return anything\;
  }  
\end{algorithm}

Algorithm \ref{algo:collect_23_ip_edges} use the line-triangle intersection algorithm for the edges of $S_4$ (line \ref{line:12edges}).
The loop produce IPs from interior of $S_3$ and possibly those already computed IPs with special position on vertex or edge of $S_4$. 
Every edge $e$ of $S_4$ is oriented so that the pair of adjacent faces $f_0$, $f_1$ apear in the same order on the intersection polygon when the 
IP of $e$ have negative sign (see Figure \ref{fig:plucker_products}). The function "edge faces" used on line \ref{line:edge_faces} and later on 
use the sign of the intersection to return the pair of faces in the correct order. 
Similarly the function "vertex faces" (Algorithm \ref{algo:vertex_faces}) described latter on
returns pair of generalized faces (face or edge) possibly adjacent to the IP $L[e]$ at the vertex $v$ of $S_4$.



\subsubsection{Vertex Faces Algorithm}
This function get an IP $p$ at vertex $v$ of $S_4$ as a parameter. The IP is special vertex case of non-degenerate edge-triangle intersection. 
The functin returns pair of generalized faces of $S_4$ preceeding and succeeding $p$ on the polygons boundary in the case that $p$ is at interior of $S_3$.
Basic idea is to use the signs of IPs of the three edges coincident with $v$. 
Possible cases are:
\begin{itemize}
 \item {\bf All IPs have same sign.} (line \ref{line:same_signs}) We return any pair of faces.  $S_3$ is touching $S_4$ 
 in the vertex $v$, the polygon ddegenerates to the single IP $p$, no connectionn information from table $F$ necessary.
 \item {\bf Single IP have sign oposite to the other two.} (line \ref{line:different_sign}) Let $e$ be the edge of the single $IP$ with different sign. 
 The plane of $S_3$ separates $e$ from the other two edges so it goes through the faces adjacent to $e$. The order is detemined by the function edge faces.
 \item {\bf Single degenerated IP.} (line \ref{line:one_degenerated}) Let us denote $e$ the edge with degenerated IP and $f$ the face between the other two edges.
 The other two (non-degenerate) edges may have either oposite sign (the plane cut $S_4$) or the same sign (the plane touching $S_4$ at the edge $e$).
 In the first case, the call of edge faces for $e$ returns $(f_x,f)$ or $(f,f_x)$, then thr vertex faces function returns $(e, f)$ or $(f, e)$, respectively.
 
 
 The edge $e$ lies in the the singel edge
 \item {\bf Two degenerated IPs.} (line \ref{line:two_degenerated}) A face of $S_4$ lies in the plane of $S_3$, single edge $e$ have non-degenerate IP.
 We treat the two degenerate edges as special case of faces adjacent to $e$ and return them sorted like the faces given by edge faces fro edge $e$.
\end{itemize}

Either all signs are equal ($S_3$ touching $S_4$) wee , or
a single edge have the sign oposite to other twotwo edges have a sign oposite then the thi. of According to the 


and need to insert them into $I$ to correct place. To this end we exploit additional information about coincidence of points
with faces of $S_4$. Every point $p$ from the first part of the algorithm \notePE{I would use proper references instead, I got confused, what 'part of algorithm' is..} that is not a vertex of $S_3$ belongs to a face $f$ of $S_4$; we know from the order of the points
whether the face comes before or after the point in the intersection polygon; in the first case we set $F[0,f] =p$, in the second case we set $F[1,f]=p$. 
Every point $p$ from the second part of the algorithm lies on an edge $e$ which is between two faces $f_0$, $f_1$. The correct order of the faces on the 
intersection polygon is determined by the sign of the edge-triangle intersection. So, having the faces in the correct order we set $F[0,f_0]=p$ and $F[1, f_1]=p$.



Finally in the third part (Algorithm \ref{algo:order_23}), the table $F$ than allows us to modify array of successors $P$ and get $I$ in correct order as the list $K$.










\begin{algorithm}
  \caption{2d-3d intersection, finish sort of points}  
  \label{algo:order_23}
  
  \SetKw{To}{to}
  \DontPrintSemicolon
  \KwIn{all points in $I$}
  \KwOut{polygon in $K$ in correct order}  
  $P=(1,\dots, n-1,0)$\tcp{array of sucessors}
  \lFor{ $f$ is face of $S_4$}{$P[ F[1,f] ] = F[0, f]$}
  $i=0$\;  
  \lFor{$n=0$ \To $\abs{I}-1$}{
    $K[n]=I[i]$
    $i=P[i]$
  }    
  \label{algo:order_23}
\end{algorithm}

  
 List $in[f]$ contains index of the intersection point that follows after $f$ on the boundary of traced polygon, 
 similarly $out[f]$ stores index of the intersection point that preeceeds the face $f$.

  
Possible cases for processing $L$:
\begin{enumerate}
 \item Regular case, $L$ consists of two intersections $p$, $q$ sorted by orientation of $s$, laying inside of $s$.
 
 If $p$ is on the edge $e$ of $S_4$ compute sign of intersection($e$, $S_3$), sort the faces $f_0$, $f_1$ coincident with $e$
 and set $in[f_0]$ to index of $p$ in $L$. Similarly if $q$ is on the edge, set $out[f_1]$ to index of $q$ in $L$.
 
 If $p$ is in vertex $v$ of $S_4$, for every face $f$ coincident with $v$ set
 in[$f$] to index of $p$ unless there is some index already set. So, we do not over ride
 entries comming from the edge intersections. Similarly set out[$f$] if $q$ is in vertex of $S_4$.
 
 If $p$ is on face $f_0$ of $S_4$, set $in[f_0]$ to index of $p$. Similarly, if $q$ is on face $f_1$ of $S_4$, set $out[f_1]$ to index of $q$.
 laying on faces $f_p$, $f_q$ of $S_4$.
 
 \item $L$ consists of a single intersection point $p$ (touching $S_4$)
 
 
 If $p$ is on edge, compute sign of intersection($e$, $S_3$), sort the faces $f_0$, $f_1$,
 set $in[f_0]$ and $out[f_1]$ to index of $p$.
 
 If $p$
\end{enumerate}

How tracing works.
\begin{itemize}
 \item If there are no intersections in vertex of $S_4$. 
\end{itemize}

  
  



intersection polygon
are found as intersection points of either triangle side and tetrahedron or tetrahedron edge and triangle.
Therefore we use both algorithms above for 1D-3D and 1D-2D, respectively. Data are again efficiently passed
to lower dimensional problems, so 

The array of intersection points is generally not sorted. We use two so called \emph{tracing} algorithms and we
intend to orient the edges of the polygon in the same direction as the triangle is oriented.
If one of the intersection point is pathologic, a general convex hull method is applied using the Monotone 
chain\footnote{Wikibooks, [online 2016-03-01], 
      \url{http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain}} 
algorithm. The points are sorted using only their barycentric coordinates.

An optimized algorithm has been suggested for non-pathologic cases. At this moment all the collected topology 
data come into play. The algorithm takes advantage by using only the data already computed and also lowers
the complexity to $O(N)$, compared with the Monotone chain complexity $O(N\log N)$ 
($N$ being number of intersection points).


\subsection{Tracking boundary of the intersection polygon}
\notePE{I suggest to denote IP, IPs intersection point and its plural respectively.}

\notePE{It seems to me, that we can really describe the prolongation in general, for 1D and 2D, 
refering to them as components. I tried to do so..}

\notePE{We need proper definitions of terms we use: \\
\emph{component} is a set of connected elements of the same lower dimension (1D, 2D)\\
\emph{bulk} is a set of 3D elements\\
% or slave, master...
\emph{candidates pair}  is a pair of a component element and a bulk element, that might intersect
each other (due to intersection of their bounding boxes or prolongation result)
\emph{pathologic, special, degenerate case ??}
}

\notePE{Do you want to use American 'neighbor' or all other English 'neighbour'? (I prefer non-american.. to be unified at the end..)}

\subsection{Prolongation algorithm}
Consider now a complex mesh of combined dimensions consisting of \emph{components}, which are sets of connected
elements of the same lower dimension (1D, 2D), in the space of 3D elements. 
Obtaining all of the 1D-3D and 2D-3D intersections is based on finding the first two elements intersecting each other.
Then we can prolongate the intersection by investigating neighbouring elements.
%
\begin{figure}[!htb]
%   \vspace{0pt}
  \centering    
    \includegraphics[width=\textwidth]{\figpath prolongation_scheme.pdf}
  \caption{Prolongation algorithm for 1D-2D and 2D-3D intersections. }
  \label{fig:prolongation}
\end{figure}

The prolongation algorithm is the same for both 1D and 2D components, see \fig{fig:prolongation}. 
It can be seen as a \emph{breadth-first search}
\footnote{Wiki, [online 2016-03-01], \url{https://en.wikipedia.org/wiki/Breadth-first_search}}
algorithm on the graph of component elements.

\textbf{breadth first search} algorithm:
  \begin{enumerate}
    \item\label{en:first} Get next unprocessed component element $k$.
    \item Find intersection candidates $\mathcal K$ in bulk mesh (3D elements).
    \item \label{en:q2}For $K\in \mathcal K$ compute intersection $(k, K)$.  
    \item Push the intersection neigbours into queues: $(k, L) \to Q_b$, $(l, K) \to Q_c$. 
    \item While $(l, L) \in Q_b$ check intersection $(l, L)$. Append queues.
    \item Pop pair from $Q_c$. (move to the next component element: go to \ref{en:q2}).
    \item If $Q_c$ is empty, go to \ref{en:first}.
  \end{enumerate}
  Prerequisites:
  \begin{itemize}
   \item need information about element connectivity (mesh preprocessing)
%   \item mark and check already inspected pairs. Marking elements + hashing.
   \item find the starting intersection -- AABB (Axes Aligned Bounding Boxes) 
   \item possibly create Bounding Interval Hierarchy (BIH)
%   \item Pass already known information with pairs.
%   \item Deal with degenerated cases.
  \end{itemize}

After computing the intersection of a pair of elements (line or triangle vs tetrahedron), we fill
two queues with element pairs as candidates for further intersection. If the intersection edge 
(point of line in 1D, edge of polygon in 2D) is inside the tetrahedron, not on its surface, we
get a neighbouring element of the component and push it back together with the current tetrahedron into 
\emph{component prolongation queue}. If the intersection edge is inside the \emph{slave} element 
(line or triangle), i.e. is on the surface of tetrahedron, we get a neighbouring element of the tetrahedron
and push it back together with the current slave element into \emph{3D prolongation queue}.

Then we empty the prolongation queues -- the 3D prolongation queue at first, then the component prolongation queue.
When both queues are empty, all intersections of a component have been found and we continue to look for
another component.

The algorithm is now unified for 1D and 2D in contrast to \cite{fris_dp_2015}, where the component prolongation
queue is emptied at first.

% \subsubsection{1D-3D prolongation}
% 1d-3d prolongation logic
% IP is:
% - 1D element node
%     - inside tetrahedron
%         - get the neighboring 1D element
%         - push to component queue candidate pair [1D neigbor -- tetrahedron]
%     - on the surface of tetrahedron
%         - get all faces in which the IP lies (1 face, or 2 faces (edge), or 3 faces (node))
%         - get the tetrahedron neighbors on the faces
%         - push to bulk queue new candidates pairs:
%             - [current 1D element -- tetrahedron neighbor]
%             - [1D neighbor -- tetragedron neighbor]
%             - check whether the candidate pair has not been computed yet
%             (- if no new prolongation, push empty pair; means IP is on the boundary; 
%                the element is not closed then -- not fully covered with tetrahedrons)
% - inside 1D element
%     - get all faces in which the IP lies (1 face, or 2 faces (edge), or 3 faces (node))
%     - get the tetrahedron neighbors on the faces
%     - push to bulk queue candidate pair [current 1D element -- tetrahedron neighbor]
%     - check whether the candidate pair has not been computed yet
%     (- if no new prolongation, push empty pair; same meaning as above)

% A new candidate pair of elements is found during prologantion, based on the topological information of the intersection point. There are 3 possible cases:

% \begin{itemize}
%     \item \textbf{IP lies at 1D element node and inside 3D element} \\
%             We find the neighboring 1D element over the node and push a new candidate pair [1D neighbor -- current 3D element] into component queue.
%     \item \textbf{IP lies at 1D element node and on the surface of 3D element} \\
%             We find all the faces of 3D element in which the IP lies (1 face, or 2 faces (IP on an edge), 
%             or 3 faces (IP at a node)). We find the corresponding neghboring 3D elements over the faces and
%             push the following new candidates pairs into the bulk queue: [current 1D element -- 3D neighbor], [1D neighbor -- 3D neighbor].
%             If the candidates pair has been investigated already, we skip it.
%     \item \textbf{IP lies inside 1D element (therefore must be on the surface of 3D element)} \\
%             The same as before, but we push only [current 1D element -- 3D neighbor] candidates pairs, since
%             there is no 1D neighbor.
% \end{itemize}

A new candidate pair of elements is found during prologantion, based on the topological information of the intersection point. There are 3 possible cases (applies both for 1D-3D and 2D-3D):
\begin{itemize}
    \item \textbf{IP lies on component element side and inside bulk element} \\
            We find all the sides of component element in which the IP lies (IP can be at node and connect more sides).
            We find the component neighboring elements over the sides and push a new candidate pair
            [component neighbor -- current bulk element] into component queue.
    \item \textbf{IP lies on component element side and on the surface of bulk element} \\
            We find all the faces of bulk element in which the IP lies (1 face, or 2 faces (IP on an edge), 
            or 3 faces (IP at a node)). We find the corresponding neighboring bulk elements over the faces and
            push the following new candidates pairs into the bulk queue: [current component element -- bulk neighbor], [component neighbor -- bulk neighbor].
            If the candidates pair has been investigated already, we skip it.
    \item \textbf{IP lies inside component element (therefore must be on the surface of bulk element)} \\
            The same as before, but we push only [current component element -- bulk neighbor] candidates pairs, since
            there is no component neighbor.
\end{itemize}

% 2d-3d prolongation logic CURRENT
% IP is:
% - inside 2D element side
%     - inside 3D element
%         - get the neighboring 2D elements over the side
%         - push to component queue candidates pair [2D neigbor -- current 3D element]
% - inside the face of 3D element
%     - get the neighboring 3D element over the face
%     - push to bulk queue candidate pair [2D neighbor -- 3D element]
% 
% 2d-3d prolongation logic WITH FUTURE CORRECTIONS
% IP is:
% - on 2D element side
%     - find 2D element sides (if at node) and the corresponding neighbors
%     - inside 3D element
%         - push to component queue candidates pairs [2D neigbor -- current 3D element]
%     - on the surface of 3D element
%         - get all faces in which the IP lies (1 face, or 2 faces (edge), or 3 faces (node))
%         - get the 3D neighbors over the faces
%         - push to bulk queue new candidates pairs
%             - [current 2D element -- 3D neighbor]
%             - [2D neighbor -- 3D neighbor] (all combinations)
%             - check whether the candidate pair has not been computed yet
% - inside the 2D element (=> on the surface of 3D element)
%     - get all faces in which the IP lies (1 face, or 2 faces (edge), or 3 faces (node))
%     - get the 3D neighbors over the faces
%     - push to bulk queue new candidates pairs [current 2D element -- 3D neighbor]
%     - check whether the candidate pair has not been computed yet


\section{Front tracking algorithm}
\section{Benchmarks}

\section{Conclusions}
TODO:
- line intersection tracking for accelerate 2D-2D intersections
- better handling of special cases in paarticular in relation to prolongations
- better calculation reuse (pass with prolongations)
- optimisation of element intersection - skip unnecessary calculations
\section{Acknowledgement}
The paper was supported in part by the Project OP
VaVpI Centre for Nanomaterials, Advanced Technologies  and Innovations
CZ.1.05/2.1.00/01.0005.


%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% If you have bibdatabase file and want bibtex to generate the
%% bibitems, please use
%%
%%  \bibliographystyle{elsarticle-harv} 
%%  \bibliography{<your bibdatabase>}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

% \begin{thebibliography}{00}
% 
% %% \bibitem[Author(year)]{label}
% %% Text of bibliographic item
% 
% \bibitem[ ()]{}
% 
% \end{thebibliography}
 %\nocite{dip}
 %\bibliographystyle{elsarticle-harv} 
 %\bibliographystyle{elsarticle-num-names} 
 \bibliographystyle{elsarticle-num} 
 \bibliography{paper_intersections.bib}
\end{document}


%\endinput
%%
%% End of file `elsarticle-template-harv.tex'.

-