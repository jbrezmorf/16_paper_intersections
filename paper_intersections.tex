%% 
%% Copyright 2007, 2008, 2009 Elsevier Ltd
%% 
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%% 
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%% SP 2008/03/01

%\documentclass[preprint,12pt]{elsarticle}
 \documentclass{elsarticle}
%\documentclass[3p,12pt,authoryear]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times,authoryear]{elsarticle}
%% \documentclass[final,1p,times,twocolumn,authoryear]{elsarticle}
%% \documentclass[final,3p,times,authoryear]{elsarticle}
%% \documentclass[final,3p,times,twocolumn,authoryear]{elsarticle}
%% \documentclass[final,5p,times,authoryear]{elsarticle}
%% \documentclass[final,5p,times,twocolumn,authoryear]{elsarticle}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor   = red %Colour of citations
}

%% For including figures, graphicx.sty has been loaded in
%% elsarticle.cls. If you prefer to use the old commands
%% please give \usepackage{epsfig}
\usepackage{subfig}

%tables
\usepackage{booktabs}
\usepackage[vlined, linesnumbered, ruled]{algorithm2e}
%\usepackage{float}
%\newfloat{algorithm}{t}{lop}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{esint}

\newtheorem{theorem}{Theorem}[section]
%\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
%\newtheorem{remark}[theorem]{Remark}
\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{thmproblem}{Problem}
%\newtheorem{exercise}[theorem]{Cvičení}


%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

% just for our notes
\usepackage[usenames,dvipsnames]{color}   %colors


\journal{Applied Mathematics and Computation}

%commands:
%\newcommand{\defref}[1]{\hyperref[#1]{Def.~\ref{#1}}}
\newcommand{\prob}[1]{Problem~{#1}}
\newcommand{\fig}[1]{\hyperref[#1]{Figure \ref{#1}}}
\newcommand{\figpath}{figures/}

%math:
\def\vc#1{\mathbf{\boldsymbol{#1}}}     % vector
\def\abs#1{\left|#1\right|}
\def\avg#1{\langle#1\rangle}
\def\d{\mathrm{d}}
\def\norm#1{\| #1 \|}
\def\abs#1{| #1 |}
\def\prtl{\partial}
\newcommand{\dd}{\; \mathrm{d}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\bx}{\vc{x}}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}


\newcommand{\noteJB}[1]{{\color{Blue} \textbf{JB: } \textit{#1}}}
\newcommand{\notePE}[1]{{\color{Orange} \textbf{PE: } \textit{#1}}}
\newcommand{\plucker}{Pl\"{u}cker }
\newcommand{\nface}{$n$-face }
\newcommand{\nfaces}{$n$-faces }

\newdefinition{mdef}{Definition}%[section]

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

%\title{Algorithm for Intersections of Nonmatching Grids of Different Dimensions}
\title{Fast Algorithms for Intersection of Nonmatching Grids Using \plucker coordinates.}


%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \address[label1]{}
%% \address[label2]{}

\author[adr]{Jan B{\v r}ezina\corref{cor1}}
\ead{jan.brezina@tul.cz}
\cortext[cor1]{Corresponding author.}

\author[adr]{Pavel Exner}
\ead{pavel.exner@tul.cz}
%\ead[url]{https://github.com/Paulie14/xfem\_project}

\address[adr]{Technical University of Liberec, Studentsk{\' a} 1402/2, 461 17 Liberec 1, Czech Republic}


\begin{abstract}
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
non-matching grid \sep 
intersections \sep
mixed-dimensional mesh \sep
\plucker coordinates


%% PACS codes here, in the form: \PACS code \sep code
%\PACS 02.60.Lj \sep        %Ordinary and partial differential equations; boundary value problems
%\PACS 02.60.Jh             %Numerical differentiation and integration

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
%\MSC[2010] 65N30 \sep %    Finite elements, Rayleigh-Ritz and Galerkin methods, finite methods
%\MSC[2010] 35J05  %    Laplacian operator, reduced wave equation (Helmholtz equation), Poisson equation

\end{keyword}

\end{frontmatter}

%% \linenumbers

%% main text
\section{Introduction}
\notePE{How did you decided for 'non-matching' term? Instead of e.g. incompatible or non-conforming?}

The grid intersection algorithms are crucial for several techniques that try to overcome some limitations of the classical finite element method.
The Chimera method \cite{brezzi_analysis_2001}, also called overset grid, and similar Nitche method \cite{massing_efficient_2013}
allow solution of the problems with changing geometry as in the fluid-structure problems. 
The Mortar method \cite{belgacem_mortar_1999} allows domain decomposition, independent meshing of domains, and supports sliding boundaries.
However our primal motivation is usage of XFEM methods and non-matching meshes of mixed dimension in groundwater models.

The realistic models of groundwater processes including the transport processes and geomechanics have to deal with 
a complex nature of geological formations including the fractures and wells. Although of small scale, these features may have significant impact 
on the global behavior of the system and their representation in the numerical model is imperative.
One possible approach is to model fractures and wells as lower dimensional objects and introduce their coupling with the surrounding continuum. 
The discretization then leads to the meshes of mixed dimensions, i.e. composed of elements of different dimension. This approach 
called mixed-dimensional analysis in the mechanics \cite{bournival_mesh-geometry_2008} is also studied in the groundwater context, see e.g. 
\cite{martin_modeling_2005}, \cite{fumagalli_numerical_2011}, \cite{brezina_analysis_2015} and 
already adopted by some groundwater simulation software, e.g FeFlow \cite{trefry_feflow:_2007} and Flow123d \cite{flow123d}.
Nevertheless as the complexity of the geometry increase (e.g. when lot of fractures are randomly generated) the compatible meshing becomes painful or even 
impossible. In order to avoid these difficulties we may discretize the continuum and every fracture and well independently getting a non-matching 
(or incompatible) mesh of mixed dimensions and then apply XFEM to represent jumps of the solution on the fractures or singularities 
around the wells. The prerequisity for such approach is a fast and robust algorithm for calculating intersections of individual meshes.

We consider a composed mesh $\mathcal T$ consisting of simplicial meshes $\mathcal T_i$ of dimensions $d_i \in \{1,2,3\}$, $i=1,\dots,N_\mathcal{T}$
in the 3d ambient space. We assume that every mesh $\mathcal T_i$ is a connected set with no self intersection.
Further we assume only single 3d mesh $\mathcal{T}_1$.
The mesh intersection problem is to find all pairs of elements $L\in \mathcal{T}_i$, $K\in \mathcal{T}_j$, $i\ne j$ that have non-empty intersection 
and to compute that intersection.

The mesh intersection problem consists of the two parts: First, generate a set of candidate pairs $(K, L)$. Second, compute the intersection for particular pair.
In order to get candidate pairs efficiently, the existing algorithms use either various space trees \cite{massing_efficient_2013} or front tracing
\cite{gander_algorithm_2013} or both \cite{elsheikh_reliable_2012} as in our approach. To compute the actual intersections, we 
use the \plucker coordinates for the line-triangle intersections and a modification of the  Platis and Theoharis algorithm \cite{platis_fast_2003}
for the line-tetrahedron intersections. These are used as the building blocks for the triangle-triangle and the triangle-tetrahedron cases.

\noteJB{Better overview of works, seems that most of works deals with simple intersections, can not find any example of 2d-3d.}

\notePE{Unify the term 'front tracing' 'front tracking' 'advancing front'.}
Our contribution is twofold:  First, we use the front tracking algorithm both to minimize set of intersection candidates as well 
to reuse part of calculations made on neighbouring intersections. Second, we present family of efficient algorithms based on \plucker coordinates 
for computing 1d-2d, 1d-3d, 2d-2d, and 2d-3d intersections of simplicies. The paper is organized as follows \dots


\section{Element Intersections}
\label{sec:elements_intersections}
In this section, we present algorithms for computing intersection of a pair of simplicial elements of a~different dimension in the 3D ambient space. 
In particular we are interested in the intersections of 1D-2D, 1D-3D, 2D-2D, 2D-3D pairs of elements. The fundamental idea is to compute intersection of 1D-2D simplices using the 
\plucker coordinates and reduce all other cases to this one. 

We denote $S_i$ a simplicial element with $i+1$ vertices (of dimension $i$). We call vertices, edges, faces and simlices itself the \nfaces and we denote
$M_i$ the set of all \nfaces of the simplex $S_i$.
In general, an intersection can be a point, a line segment or a polygon called \emph{intersection polygon} (IP) in common.
The intersection polygon is represented as a list of its corners called \emph{intersection corners} (IC). The IP data structure keeps also 
reference to the intersecting simplices. A data structure of a single IC consists of:
\begin{itemize}
 \item the barycentric coordinate $\vc w_K$ of IC on $K$,
 \item the dimension $d_K$ of the most specific \nface the IC lies on,
 \item the local index $i_K$ of that \nface on $K$,
\end{itemize}
for each intersecting element $K$ of the pair. The pair $\tau_K = (d_K, i_K)$
we call the topological position of the IC on $K$.


\subsection{\plucker Coordinates}
\plucker coordinates represent a line in 3D space.
Considering a line $p$, given by a point $\vc A$ and its directional vector $\vc{u}$, 
the \plucker coordinates of $p$ are defined as
\[ \pi_p = (\vc{u}_p, \vc{v}_p) = (\vc{u}_p, \vc{u}_p\times A). \]
Further we use a permuted inner product
\[\pi_p \odot \pi_q = \vc{u}_p\cdot \vc{v}_q + \vc{u}_q \cdot \vc{v}_p. \]

The sign of the permuted inner product gives us the relative position of the two lines, 
see \fig{fig:plucker_products}.



\begin{figure}[!htb]
  \begin{center}        
    \includegraphics[width=0.7\textwidth]{\figpath plucker_product.pdf}
%    \includegraphics{\figpath plucker_products.pdf}
  \end{center}
  \caption{Sign of the permuted inner product is related to the relative position of the two oriented lines. Dashed line symbolizes that the line is in the back, the lines intersect in the middle case.
           \notePE{circle dot permuted inner product}}
  \label{fig:plucker_products}
\end{figure}


%Notice the condition on the orientation of the triangle sides. To always satisfy it, we use a
%reference simplex, in which the numbering of nodes and sides and also the orientation is fixed.
%The barycentric coordinates of the intersection corner can be computed directly from the \plucker products
%and then we can easily obtain its real coordinates (see \cite{fris_dp_2015} for derivations and details).

\subsection{Intersection Line-Triangle (1D-2D)}
Let us consider a line segment $p$ with parametric equation 
\begin{equation}
    \label{eq:line_parametric}
    \vc X = \vc A + t\vc u,\ t\in (0,1)
\end{equation}
and a triangle $T$ given by vertices $(\vc V_0, \vc V_1, \vc V_2)$ 
with oriented sides $s_i=(\vc V_j, \vc V_k)$, $j=(i+1)\text{ mod }3$, $k=(i+2)\text{ mod }3$. 
\begin{lemma}
The permuted inner products $\pi_p \odot \pi_{s_i},\, i=0,1,2$ have the same non-zero sign if and only if there
is an intersection point $X$ on the $p$ and inside the triangle $T$. 
The barycentric coordinates of $X$ on $T$ are
\begin{equation}
  \label{eq:bary_centric}
   w_i = \frac{\pi_p \odot \pi_{s_i}}{ \sum_{j=0}^{2} \pi_p \odot \pi_{s_i} }.
\end{equation}
\end{lemma}
\begin{proof}
Using the barycentric coordinates the intersection point can be expressed as $\vc X = \vc V_0 + w_1 \vc s_2 - w_2 \vc s_1$.
The line $p$ have \plucker coordinates $(\vc u, \vc u \times \vc X)$ since these are invariant to change of the initial point. 
Combining these two expressions we get
\[
   \pi_p \odot \pi_{s_1} = \vc u \cdot (\vc s_1 \times \vc V_2) + \vc s_1 \cdot ( \vc u \times [\vc V_0 + w_1\vc s_2 - w_2 \vc s_1])
   =-w_1 \vc u \cdot (\vc s_1 \times \vc s_2).
\]
Since $\vc s_0 + \vc s_1 + \vc s_2=0$ we have $ \vc s_1 \times \vc s_2 = \vc s_2 \times \vc s_0 = \vc s_0 \times \vc s_1$ and thus
\[
   \pi_p \odot \pi_{s_i} = -w_i \vc u \cdot (\vc v_1 \times \vc v_2).
\]
The point $X$ is inside of $T$ if and only if $w_i>0$ for all $i=0,1,2$.
\end{proof}
Having the barycentric coordinates of $X$ on $T$, we can compute also its local coordinate on $p$ from its parametric form:
\begin{equation}
   \label{eq:line}
   X_i  = A_i + t u_i, \text{ for } i=1,2,3
\end{equation}
We use $i$ with maximal $|u_i|$ for practical computation. 

The calculation of the intersection proceeds as follows:
\begin{enumerate}
    \item Compute or reuse \plucker coordinates and permuted inner products: $\pi_p$, $\pi_i$, $\pi_s \odot \pi_i$, for $i=1,2,3$.
    \item Compute barycentric coordinates $w_i,\ i=1,2,3$ using \eqref{eq:bary_centric}.
    \item If any $w_i$ is less then $\epsilon$ there is no intersection, return empty IP.  
    \item If all $w_i$ are greater then $\epsilon$, we set $\tau_T = (2, 0)$ for the IC.
    \item If one $w_i$ is less then $\epsilon$, intersection on edge $s_i$, we set $\tau_T =(1,i)$.
    \item If two $w_i$ are less then $\epsilon$, intersection in the vertex $V_i$, we set $\tau_T=(0,,i)$.
    \item \label{item:coplanar} If all $w_i$ are less then $\epsilon$, the line is coplanar with the triangle, both objects are 
        projected to the plane $x_i=0$ where $i$ is the index of maximal component of the triangle's normal vector.
        Every pair $p$, $s_i$ is checked for an intersection on $T$ boundary either inside $s_i$ or in a vertex $V_i$ setting the topological info $\tau_T$ to 
        $(1, i)$ or $(0, i)$ respectively. At most two ICs are obtained.
    \item For each IC the barycentric coordinates $(1-t, t)$ on the line $p$ are computed according to \eqref{eq:line}. 
    \item If $t\in (-\epsilon, \epsilon)$ or $t\in (1-\epsilon, 1+\epsilon)$, we set $\tau_p = (0,0)$ or $\tau_p = (0,1)$, respectively.
    \item If $t\notin (-\epsilon, 1+\epsilon)$, the IC is eliminated.
\end{enumerate}

The check for the same sign of the inner products can be viewed as a geometric predicate for the presence of the intersection and orientation of the 
line with respect to the triangle. Adaptive-precision evaluation of the geometric predicates was designed by Schewchuk \cite{shewchuk_adaptive_1997}
and used for 2d-2d mesh intersections in \cite{elsheikh_reliable_2012}. However, we rather apply a fixed tolerance check for the zero 
barycentric coordinates and consistently keep the topological positions in this and related algorithms. \noteJB{Can we make the algorithm 
\emph{parsimonious} in the spirit of the Fortune \cite{fortune_stable_1989} quoted by Schewchuk? 
Seems that our problem is more local than the line example that was proven to be NP-hard.}

The algorithms for 1d-3d and 2d-3d intersections use simpler version of the 1d-2d intersection algorithm, in particular the search for ICs in the coplanar case 
(item \ref{item:coplanar}) is not necessary and the test in the last point is not performed.
and degenerate cases higher dimensional cases.

\subsection{Intersection Line-Teraherdon (1D-3D)}
In this section we consider intersection of a line segment $p$ given by the parametric equation \eqref{eq:line_parametric} with a tetrahedron 
$S_3$. The used algorithm is based on 1d-2d algorithm and closely follows \cite{platis_fast_2003}. Our modification takes into account
intersection with a line segment and consistently propagates topological position of ICs.

\begin{algorithm}
  \caption{1d-3d intersection}
  \label{algo:13d}

  \DontPrintSemicolon
  \SetKw{and}{and}
  \SetKw{continue}{continue}
  \SetKw{break}{break}
  \KwIn{Tetrahedron $S_3$, line segment $p$.}
  \KwOut{List of ICs on sorted along $p$.}  
  $I=\{\}$ 
  \For{unmarked face $f$ of $S_3$}{
    $L$ = intersection($p,\ f$)\;
    \lIf{ $L$ is none or degenerate}{\continue}
    \lIf{ $L$ is inside the edge $e$}{
        set $\tau_{S_4} = (1,e)$\;
        mark faces coincident with $e$
    }
    \ElseIf{ $L$ is at the vertex $v$}{
        set $\tau_{S_4} = (0,v)$\;
        mark faces coincident with $v$
    }
    append $L$ to $I$
    \lIf{$\abs{I}=2$}{\break} 
  }
  \lIf{$\abs{I}=1$ \and   $I$ is outside of $p$}{ erase $I$}
  \ElseIf{$\abs{I}=2$}{    
    trim intersection with respect to the line segment $p$ \label{line:trimming}
  }
\end{algorithm}
Algorithm \ref{algo:13d} first compute line-face intersections for every face of $S_4$ avoiding duplicate computation of ICs on edges and at vertices and
skipping remaining faces once two ICs are found. Tetrahedron has six edges, so 7 \plucker coordinates and 6 inner products are computed at most. Precomputed 
coordinates and products are passed the 1D-2D algorithm which is performed fro the whole line $p$. After collecting line-tetrahedron ICs,
we do the line segment trimming \ref{line:trimming}. If both ICs are out of the line segment $p$ we eliminate both of them. If one of the ICs if out of $p$
we use the closest end point of the line segment instead and interpolate barycentric coordinates of the IC on $S_4$. The topological positions are updated as well.
The result of the algorithm are zero up to two ICs sorted by the parameter $t$ of the line $p$.

\subsection{Intersection Triangle-Tetrahedron (2D-3D)}
The intersection of a triangle $S_2$ and a tetrahedron $S_3$ is an $n$-side polygon, $n\le 7$. The sides of the polygon
lie either on sides of $S_2$ or on faces of $S_3$. Thus each vertex (IC) of the polygon
can arise either from side-face intersection, or from edge-triangle intersection, or be a vertex of $S_2$.
So we have to compute at most 12 side-face intersections and at most 6 edge-triangle intersections. However,
to this end we only need to compute 9 \plucker coordinates (3 sides, 6 edges) and 18 permuted inner produts, one for every side-edge pair.
Computation of the intersection polygon consists of two parts: calculation of side-tetrahedron ICs (Algorithm \ref{algo:colect_23_ip_triangle})
provides all ICs on the boundary of $S_2$,
calculation of edge-triangle ICs (Algorithm \ref{algo:collect_23_ip_edges}).
\notePE{The following sentence is somehow weird.. I would say that we store ICs $I$; to sort $I$ during the computation, we use the two tables; at the end, $I$ is ordered correctly.}
Correct order of the ICs, stored in the list $I$, is defined by the \emph{connection tables} $F_g(:)$ and $F_p(:)$. \notePE{The following sentece is a copy of the second sentence is this subsection.} Every side of the intersection polygon 
lies either on a side of $S_2$, or on a face, or on an edge of $S_3$. Let us denote $M_2$ the set of sides of $S_2$ and $M_3$ the set of volume,
faces, edges, and vertices of $S_3$. Every side of polygon that lies on $x\in M_2\cup M_3$ is followed by an IC given by $F_g[x]$ 
and every IC $p$ is followed by the side that lies on $F_p[p]\in M_2\cup M_3$. 

\begin{algorithm}
  \caption{2d-3d intersection, points on triangle boundary}
  \label{algo:colect_23_ip_triangle}

  \DontPrintSemicolon
  \SetKw{continue}{continue}
  \KwIn{input data}
  \KwOut{List of ICs on sorted output data}  
  $F_g(:)=-1,\ F_p(:)=-1$\tcp*{Unset links.} 
  \For{side $s$ of $S_2$}{ 
    $L$ = intersection($s, S_3$)\;
    \lIf{ $\abs{L} = 0$}{\continue}
    \lIf{ $\abs{L} = 1$}{
        append $p$ to $J$
        \continue
    }
    \For{$p$ in $L$}{
        \lIf{$p \ne I[-1]$ }{append $p$ to $I$}
        \nllabel{line:m4_object}
        $p$ lies on $x\in M_3$\; 
        \uIf{$p$ is first in $L$}{
            $F_g[x] = p$,\ $F_p[p] = s$\;
        }
        \Else($p$ is the last in $L$){
            $F_g[s] = p,\ F_p[p] = x$\;
            \lIf{$F_g[x] = -1$}{$F_g[x] = p$} \nllabel{line:back_link43}
        }
    }
  }  
  \If{$I[-1] = I[0]$}{
    $x = F_p[I[-1]]$\;
    \If{$F_g[x]]=I[-1]$}{$F_g[x]=I[0]$}
    $F_g[s_2] = I[0]$\;
    remove $I[-1]$
  }
\end{algorithm}


Algorithm \ref{algo:colect_23_ip_triangle} passes through every side $s$ of the triangle $S_2$ and computes the line-tetrahedron intersection $L$.
In the regular case we process each of the two ICs in $L$. The IC $p$ is added to the list $I$ unless the last point is the same. 
This condition is effective just for the first IC in $L$ and merges ICs at the same vertex of $S_2$. Then we identify an object $x\in M_3$ the point
$p$ lies on (line \ref{line:m4_object}). \notePE{I am not sure, if the term 'object' is clear..}

\notePE{Why calling it vertex $v$ instead of IC $p$ here? What is $y$?}
If the vertex $v$ is between sides $s_1$, $s_2$, 
we effectively set connections $F_g[s_1] = v$, $F_g[y]=v$, $F_p[v] = s_2$. The backward temporary link on the line \ref{line:back_link43} 
is used in Algorithm \ref{algo:collect_23_ip_edges} to fix $F_p[p]$ for the second $p$ lying on an edge or a vertex of $S_3$. The condition at the end deals with the case
in which two sides intersect the same object $x\in M_3$.


For the regular intersection $L$, we pass through its ICs, as described above. \notePE{For special cases}, we firstly compute ICs
on the boundary of $S_2$ using the line-tetrahedron intersection algorithm for every side. We store single point intersections into separate list $J$
and skip filling the connection tables. This happens when the side touches $S_3$ at its edge or vertex. 
These ICs will be rediscovered again in Algorithm \ref{algo:collect_23_ip_edges} with better topological information, however
this is not the case if the touched edge $e$ of $S_3$ is coplanar with $S_2$ and the IC is inside of $e$. 
Therefore we keep a separate list $J$ of ICs to deal with this case.


\begin{algorithm}  
  \caption{2d-3d intersection, points in triangle interior}
  \label{algo:collect_23_ip_edges}
  
  \SetKw{And}{And}
  \SetKw{edgefaces}{edge faces}
  \SetKw{vertexfaces}{vertex faces}
  \DontPrintSemicolon
  \KwIn{$I$ with ICs on $S_2$ boundary, partially filled $F$}
  \KwOut{all ICs in $I$, complete $F$}  
  
  \lFor{edge $e$ of $S_3$}{$L[e]$ = intersection($e, S_2$)}  \nllabel{line:12edges}
  \For{unmarked edge $e$ of $S_3$}{
    $p=L[e]$\;
    \uIf{ $p$ is inside $e$}{ 
        \nllabel{line:edge_faces}        
        $(f_0,\ f_1)$ = \edgefaces($e$)
    } 
    \Else($p$ at the vertex $v$ of $S_3$){       
            $(f_0,\ f_1)$ = \vertexfaces($v$,$L$)   \tcp*{Algorithm \ref{algo:vertex_faces}}
            \nllabel{line:mark_edges}
            mark all edges coincident with $p$
    }    
    \uIf{ $p$ is on boundary of $S_2$ }{
         $p$ lies on edge or at vertex $x \in M_3$\;
         $q=F_g[x]$\tcp*{$q$ is already computed $p$}
         \lIf{$F_p[q]=x$}{$F_p[q]=f_1$}
         \lElse{$F_g[f_0]=q$}
         $F_g[x]=-1$\tcp*{remove the backlink}
    }
    \Else{
         append $p$ to $I$\;
         $F_g[f_0]=p$\tcp*{overwrite the backlink}
         $F_p[p]=f_1$\;         
    }   
  }  
  
  \lIf{$\abs{I} < 3$}{ return $J$}
  \lElse{ return $I$ sorted according to connectivity in $F_g$ and $F_p$}
\end{algorithm}

\begin{algorithm}
  \caption{2d-3d intersection, vertex faces}  
  \label{algo:vertex_faces}
  
  \SetKw{return}{return}
  \SetKw{edgefaces}{edge faces}
  \DontPrintSemicolon
  \KwIn{vertex $v$ of $S_3$, $L[:]$ intersection results for edges of $S_3$}
  \KwOut{$(x_1, x_2)$, $x_1, x_2 \in M_3$, coincident with $v$ and intersected by the plane of $S_2$}
  $e_0,\ e_1,\ e_2$ edges coincident with $v$ oriented out of $v$
  $s[i] = L[e_i]$, for $i=0,1,2$, \;
  
  \uIf{$s[:]$ have 1 non-degenerate edge $e$}{ \nllabel{line:two_degenerated}
    \return pair of degenerate edges sorted according to \edgefaces($e$)    
  }
  
  \uElseIf{ $s$ have 1 degenerate edge $e$}{\nllabel{line:one_degenerated}
    $f$ is face opposite to $e$
    \uIf{other two edges $e_a$, $e_b$ have different sign}{
        $z=\edgefaces(e_a)$\;
        replace $g\in z$, $g\ne f$ with $e$
        \return $z$
    }\lElse{
        append IC of $v$ to $J$
        \return anything\;
    }
  }
  
  \uElseIf{ $s$ have edge $e$ with sign oposite to other two}{ \nllabel{line:different_sign}
    \return edge faces($e$)\;
  }
  
  \Else($s$ have all signs same){ \nllabel{line:same_signs}
    append IC of $v$ to $J$
    \return anything\;
  }  
\end{algorithm}

Algorithm \ref{algo:collect_23_ip_edges} uses the line-triangle intersection algorithm for the edges of $S_3$ (line \ref{line:12edges}).
The loop produces ICs in the interior of $S_2$ and possibly those ICs with special position on vertex or edge of $S_3$ already computed in Algorithm \ref{algo:colect_23_ip_triangle}. 
Every edge $e$ of $S_3$ is oriented so that the pair of adjacent faces $f_0$, $f_1$ appears in the same order on the intersection polygon when the 
IC on $e$ has a negative sign (see Figure \ref{fig:plucker_products}). The function \emph{edge faces}, used on line \ref{line:edge_faces} and later on,
uses the sign of the intersection to return the pair of faces ordered correctly. 
Similarly the function \emph{vertex faces} (Algorithm \ref{algo:vertex_faces}, described later)
returns a pair of generalized faces (face or edge) possibly adjacent to the IC $L[e]$ at the vertex $v$ of $S_3$.
On line \ref{line:mark_edges} we mark all edges coincident with the vertex, since if they have any other intersection corner they are degenerate and 
not processed anyway.


\subsubsection{Vertex Faces Algorithm}
This function gets an IC $p$ at vertex $v$ of $S_3$ as a parameter. The IC is special vertex case of non-degenerate edge-triangle intersection. 
The function returns a pair of generalized faces of $S_3$ preceeding and succeeding $p$ on the polygons boundary in the case that $p$ is at interior of $S_2$.
The basic idea is to use the signs of ICs of the three edges coincident with $v$. 
Possible cases are:
\begin{itemize}
 \item {\bf All ICs have the same sign.} (line \ref{line:same_signs}) We return any pair of faces.  $S_2$ is touching $S_3$ 
 at the vertex $v$, the polygon degenerates into the single IC $p$, no connection information from table $F$ is necessary.
 \item {\bf Single IC has the opposite sign to the other two.} (line \ref{line:different_sign}) Let $e$ be the edge of the single IC with the different sign. 
 The plane of $S_2$ separates $e$ from the other two edges so it goes through the faces adjacent to $e$. The order is detemined by the function \emph{edge faces}.
 \item {\bf Single degenerated IC.} (line \ref{line:one_degenerated}) Let us denote $e$ the edge with degenerated IC and $f$ the face between the other two edges.
 The other two (non-degenerates) edges may have either the opposite sign (the plane is cutting $S_3$) or the same sign (the plane is touching $S_3$ at the edge $e$).
 In the first case, the call of edge faces for $e$ returns $(f_x,f)$ or $(f,f_x)$, then the vertex faces function returns $(e, f)$ or $(f, e)$, respectively.
 
 
 The edge $e$ lies in the the singel edge
 \item {\bf Two degenerated ICs.} (line \ref{line:two_degenerated}) A face of $S_3$ lies in the plane of $S_2$, single edge $e$ have non-degenerate IC.
 We treat the two degenerate edges as special case of faces adjacent to $e$ and return them sorted like the faces given by edge faces of edge $e$.
\end{itemize}

% Either all signs are equal ($S_2$ touching $S_3$) wee , or
% a single edge have the sign oposite to other twotwo edges have a sign oposite then the thi. of According to the 
% 
% 
% and need to insert them into $I$ to correct place. To this end we exploit additional information about coincidence of points
% with faces of $S_3$. Every point $p$ from the first part of the algorithm \notePE{I would use proper references instead, I got confused, what 'part of algorithm' is..} that is not a vertex of $S_2$ belongs to a face $f$ of $S_3$; we know from the order of the points
% whether the face comes before or after the point in the intersection polygon; in the first case we set $F[0,f] =p$, in the second case we set $F[1,f]=p$. 
% Every point $p$ from the second part of the algorithm lies on an edge $e$ which is between two faces $f_0$, $f_1$. The correct order of the faces on the 
% intersection polygon is determined by the sign of the edge-triangle intersection. So, having the faces in the correct order we set $F[0,f_0]=p$ and $F[1, f_1]=p$.



Finally in the third part (Algorithm \ref{algo:order_23}), the table $F$ allows us to modify array of successors $P$ and get $I$ in the correct order as the list $K$.










\begin{algorithm}
  \caption{2d-3d intersection, finish sort of points}  
  \label{algo:order_23}
  
  \SetKw{To}{to}
  \DontPrintSemicolon
  \KwIn{all points in $I$}
  \KwOut{polygon in $K$ in correct order}  
  $P=(1,\dots, n-1,0)$\tcp{array of sucessors}
  \lFor{ $f$ is face of $S_3$}{$P[ F[1,f] ] = F[0, f]$}
  $i=0$\;  
  \lFor{$n=0$ \To $\abs{I}-1$}{
    $K[n]=I[i]$
    $i=P[i]$
  }    
  \label{algo:order_23}
\end{algorithm}

  
 List $in[f]$ contains index of the intersection corner that follows after $f$ on the boundary of traced polygon, 
 similarly $out[f]$ stores index of the intersection corner that preeceeds the face $f$.

  
Possible cases for processing $L$:
\begin{enumerate}
 \item Regular case, $L$ consists of two intersections $p$, $q$ sorted by orientation of $s$, laying inside of $s$.
 
 If $p$ is on the edge $e$ of $S_3$ compute sign of intersection($e$, $S_2$), sort the faces $f_0$, $f_1$ coincident with $e$
 and set $in[f_0]$ to index of $p$ in $L$. Similarly if $q$ is on the edge, set $out[f_1]$ to index of $q$ in $L$.
 
 If $p$ is in vertex $v$ of $S_3$, for every face $f$ coincident with $v$ set
 in[$f$] to index of $p$ unless there is some index already set. So, we do not over ride
 entries comming from the edge intersections. Similarly set out[$f$] if $q$ is in vertex of $S_3$.
 
 If $p$ is on face $f_0$ of $S_3$, set $in[f_0]$ to index of $p$. Similarly, if $q$ is on face $f_1$ of $S_3$, set $out[f_1]$ to index of $q$.
 laying on faces $f_p$, $f_q$ of $S_3$.
 
 \item $L$ consists of a single intersection corner $p$ (touching $S_3$)
 
 
 If $p$ is on edge, compute sign of intersection($e$, $S_2$), sort the faces $f_0$, $f_1$,
 set $in[f_0]$ and $out[f_1]$ to index of $p$.
 
 If $p$
\end{enumerate}

How tracing works.
\begin{itemize}
 \item If there are no intersections in vertex of $S_3$. 
\end{itemize}

  
  



intersection polygon
are found as intersection corners of either triangle side and tetrahedron or tetrahedron edge and triangle.
Therefore we use both algorithms above for 1D-3D and 1D-2D, respectively. Data are again efficiently passed
to lower dimensional problems, so 

The array of intersection corners is generally not sorted. We use two so called \emph{tracing} algorithms and we
intend to orient the edges of the polygon in the same direction as the triangle is oriented.
If one of the intersection corner is pathologic, a general convex hull method is applied using the Monotone 
chain\footnote{Wikibooks, [online 2016-03-01], 
      \url{http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain}} 
algorithm. The points are sorted using only their barycentric coordinates.

An optimized algorithm has been suggested for non-pathologic cases. At this moment all the collected topology 
data come into play. The algorithm takes advantage by using only the data already computed and also lowers
the complexity to $O(N)$, compared with the Monotone chain complexity $O(N\log N)$ 
($N$ being number of intersection corners).


\subsection{Tracking boundary of the intersection polygon}

\notePE{It seems to me, that we can really describe the prolongation in general, for 1D and 2D, 
refering to them as components. I tried to do so..}

\notePE{We need proper definitions of terms we use: \\
% \emph{component} is a set of connected elements of the same lower dimension (1D, 2D)\\
% \emph{bulk} is a set of 3D elements\\
% or slave, master...
\emph{candidates pair}  is a pair of a component element and a bulk element, that might intersect
each other (due to intersection of their bounding boxes or prolongation result)
\emph{pathologic, special, degenerate case ??}
}

\notePE{Do you want to use American 'neighbor' or all other English 'neighbour'? (I prefer non-american.. to be unified at the end..)}


\section{Advancing Front Method}

add references...
% BIH:
% http://ainc.de/Research/BIH.pdf
% http://diglib.eg.org/handle/10.2312/EGWR.EGSR06.139-149

Consider now a complex mesh of combined dimensions consisting of \emph{components}, which are sets of connected
elements of the same lower dimension (1D, or 2D), in the space of connected 3D elements, which we shall call a \emph{bulk}. 
Obtaining all of component-bulk intersections is done in two phases: firstly, we look for the first two elements intersecting each other (initialization); secondly, we prolong the intersection by investigating neighbouring elements (intersection tracking).

To construct the Advancing front algorithm, we shall need:
\begin{itemize}
    \item \textbf{element connectivity} -- we assume this data is available from mesh preprocessing,
    \item \textbf{Axes Aligned Bounding Boxes (AABB)} -- we construct these in order to decide fastly
                    whether to compute the actual intersection of two elements,
    \item \textbf{Bounding Interval Hierarchy (BIH)} -- we alternatively create BIH above AABB to fastly search 
                    created bounding boxes for two coinciding with each other and thus obtaining a candidate pair.
\end{itemize}


The intersection tracking itself can be also seen as a \emph{breadth-first search}
\footnote{Wiki, [online 2016-03-01], \url{https://en.wikipedia.org/wiki/Breadth-first_search}}
algorithm over the BIH, following the component elements.

% \textbf{breadth first search} algorithm:
%   \begin{enumerate}
%     \item\label{en:first} Get next unprocessed component element $k$.
%     \item Find intersection candidates $\mathcal K$ in bulk mesh (3D elements).
%     \item \label{en:q2}For $K\in \mathcal K$ compute intersection $(k, K)$.  
%     \item Push the intersection neigbours into queues: $(k, L) \to Q_b$, $(l, K) \to Q_c$. 
%     \item While $(l, L) \in Q_b$ check intersection $(l, L)$. Append queues.
%     \item Pop pair from $Q_c$. (move to the next component element: go to \ref{en:q2}).
%     \item If $Q_c$ is empty, go to \ref{en:first}.
%   \end{enumerate}

\paragraph{Initialization}
We start with selecting an arbitrary 1D or 2D element. Then we search the bulk elements, checking for 
a collision of bounding boxes, to create a candidate pair. Using only AABB, we need to iterate over
bulk elements in $O(n)$, $n$ being the number of all elements in our case. Using BIH, we can speed 
up the search to $O(\log n)$ on average. In later case, we are paying the costs in the construction of BIH,
which is a quicksort like algorithm running at $O(n\log n)$ on average.

Now that we have provided the first candidate pair, we can look at the scheme in \fig{fig:prolongation} and see us moving from the green box in the left upper corner. If an intersection exists, we have just started a new component and we can procced to tracking the intersection. Otherwise, we select another 1D or 2D element and start over.

%
\begin{figure}[!htb]
%   \vspace{0pt}
  \centering    
    \includegraphics[width=\textwidth]{\figpath prolongation_scheme_ip.pdf}
  \caption{Advancing front algorithm for 1D-2D and 2D-3D intersections.}
  \label{fig:prolongation}
\end{figure}

Let us now discuss the advancing front algorithm displayed by the scheme in \fig{fig:prolongation}. The main idea is to compute intersections for a component element with all possible bulk elements, and then move to a~next neighboring component element. For this reason, we define two
queues of candidate pairs: a~\emph{bulk queue} and a~\emph{component queue} (yellow boxes).

On input we consider a candidate pair, for which a non-empty intersection is computed.
Now we look for new candidate pairs among the neighboring elements (the block Prolongation decide).
Therefore, we iterate over the intersection points and further exploit the topological information.
There are 3 possible cases (applies both for 1D-3D and 2D-3D), how the intersection might be prolonged:
\begin{itemize}
    \item \textbf{IP lies on the component element side and inside the bulk element} \\
            We find all the sides of component element in which the IP lies (IP can be at node and connect more sides).
            Next, we find the component neighboring elements over the sides and push all new candidate pairs
            [component neighbor -- current bulk element] into the component queue.
            Note, that there can be more than one neighbor on a side, if the component has branches.
    \item \textbf{IP lies on the component element side and on the surface of the bulk element} \\
            We find all the faces of bulk element in which the IP lies (1 face, or 2 faces (IP on an edge), 
            or 3 faces (IP at a node)). We find the corresponding neighboring bulk elements over the faces and
            push the new candidate pairs [current component element -- bulk neighbor] into the bulk queue and [component neighbor -- bulk neighbor] into the component queue.
    \item \textbf{IP lies inside component element (therefore must be on the surface of bulk element)} \\
            We proceed as in previous case, but we push only [current component element -- bulk neighbor] candidate pairs, since there is no component neighbor.
\end{itemize}

If the candidate pair has been found already, we skip it.
We also see that the candidate pairs are of three types:
[current component element -- bulk neighbor],
[component neighbor -- current bulk element], 
[component neighbor -- bulk neighbor],
from which only the first one goes into the bulk queue, trying to cover the whole component element.


% After computing the intersection of a pair of elements (line or triangle vs tetrahedron), we fill
% two queues with element pairs as candidates for further intersection. If the intersection edge 
% (point of line in 1D, edge of polygon in 2D) is inside the tetrahedron, not on its surface, we
% get a neighbouring element of the component and push it back together with the current tetrahedron into 
% \emph{component prolongation queue}. If the intersection edge is inside the \emph{slave} element 
% (line or triangle), i.e. is on the surface of tetrahedron, we get a neighbouring element of the tetrahedron
% and push it back together with the current slave element into \emph{3D prolongation queue}.


Then we empty the two queues. 
We pop out new candidate pairs from the \emph{bulk queue} as long as it is not empty and for every new intersection computed, we repeat the previous part (means that we can further fill both queues).
The \emph{bulk queue} is empty when the component element is fully covered by bulk elements, or
when there is no bulk neighbor to which we can advance.
Then we can pop a new candidate pair from \emph{component prolongation queue} and process it.
When both queues are empty, all intersections of a component have been found and we start over by looking for the first intersection of another component.

\notePE{We can discuss further the covering/closing of the elements and component numbering which is not tested
thoroughly at the moment. We can show in a figure the case in 'prolong\_meshes\_13d/prolongation\_13d\_04.msh', where actually 4 components are found (therefore bulk is defined as connected 3D elements).}

% The algorithm is now unified for 1D and 2D in contrast to \cite{fris_dp_2015}, where the component prolongation
% queue is emptied at first.

% \subsubsection{1D-3D prolongation}
% 1d-3d prolongation logic
% IC is:
% - 1D element node
%     - inside tetrahedron
%         - get the neighboring 1D element
%         - push to component queue candidate pair [1D neigbor -- tetrahedron]
%     - on the surface of tetrahedron
%         - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%         - get the tetrahedron neighbors on the faces
%         - push to bulk queue new candidates pairs:
%             - [current 1D element -- tetrahedron neighbor]
%             - [1D neighbor -- tetragedron neighbor]
%             - check whether the candidate pair has not been computed yet
%             (- if no new prolongation, push empty pair; means IC is on the boundary; 
%                the element is not closed then -- not fully covered with tetrahedrons)
% - inside 1D element
%     - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%     - get the tetrahedron neighbors on the faces
%     - push to bulk queue candidate pair [current 1D element -- tetrahedron neighbor]
%     - check whether the candidate pair has not been computed yet
%     (- if no new prolongation, push empty pair; same meaning as above)

% A new candidate pair of elements is found during prologantion, based on the topological information of the intersection corner. There are 3 possible cases:

% \begin{itemize}
%     \item \textbf{IC lies at 1D element node and inside 3D element} \\
%             We find the neighboring 1D element over the node and push a new candidate pair [1D neighbor -- current 3D element] into component queue.
%     \item \textbf{IC lies at 1D element node and on the surface of 3D element} \\
%             We find all the faces of 3D element in which the IC lies (1 face, or 2 faces (IC on an edge), 
%             or 3 faces (IC at a node)). We find the corresponding neghboring 3D elements over the faces and
%             push the following new candidates pairs into the bulk queue: [current 1D element -- 3D neighbor], [1D neighbor -- 3D neighbor].
%             If the candidates pair has been investigated already, we skip it.
%     \item \textbf{IC lies inside 1D element (therefore must be on the surface of 3D element)} \\
%             The same as before, but we push only [current 1D element -- 3D neighbor] candidates pairs, since
%             there is no 1D neighbor.
% \end{itemize}



% 2d-3d prolongation logic CURRENT
% IC is:
% - inside 2D element side
%     - inside 3D element
%         - get the neighboring 2D elements over the side
%         - push to component queue candidates pair [2D neigbor -- current 3D element]
% - inside the face of 3D element
%     - get the neighboring 3D element over the face
%     - push to bulk queue candidate pair [2D neighbor -- 3D element]
% 
% 2d-3d prolongation logic WITH FUTURE CORRECTIONS
% IC is:
% - on 2D element side
%     - find 2D element sides (if at node) and the corresponding neighbors
%     - inside 3D element
%         - push to component queue candidates pairs [2D neigbor -- current 3D element]
%     - on the surface of 3D element
%         - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%         - get the 3D neighbors over the faces
%         - push to bulk queue new candidates pairs
%             - [current 2D element -- 3D neighbor]
%             - [2D neighbor -- 3D neighbor] (all combinations)
%             - check whether the candidate pair has not been computed yet
% - inside the 2D element (=> on the surface of 3D element)
%     - get all faces in which the IC lies (1 face, or 2 faces (edge), or 3 faces (node))
%     - get the 3D neighbors over the faces
%     - push to bulk queue new candidates pairs [current 2D element -- 3D neighbor]
%     - check whether the candidate pair has not been computed yet





\section{Benchmarks}

\section{Conclusions}
TODO:
- line intersection tracking for accelerate 2D-2D intersections
- better handling of special cases in paarticular in relation to prolongations
- better calculation reuse (pass with prolongations)
- optimisation of element intersection - skip unnecessary calculations
\section{Acknowledgement}
The paper was supported in part by the Project OP
VaVpI Centre for Nanomaterials, Advanced Technologies  and Innovations
CZ.1.05/2.1.00/01.0005.


%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% If you have bibdatabase file and want bibtex to generate the
%% bibitems, please use
%%
%%  \bibliographystyle{elsarticle-harv} 
%%  \bibliography{<your bibdatabase>}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

% \begin{thebibliography}{00}
% 
% %% \bibitem[Author(year)]{label}
% %% Text of bibliographic item
% 
% \bibitem[ ()]{}
% 
% \end{thebibliography}
 %\nocite{dip}
 %\bibliographystyle{elsarticle-harv} 
 %\bibliographystyle{elsarticle-num-names} 
 \bibliographystyle{elsarticle-num} 
 \bibliography{paper_intersections.bib}
\end{document}




\cite{sukumar_extended_2000} - Use {\emph geometric predicates} incircle and orientation. Use mesh of bounding boxes to search for intersection candidates. 
Only use point queries for all vertices of triangle/tetrahedron. Use compatible partitioning of elements by the crack elements.

\cite{boon_robust_2016} Robust discretization of porous media. Complete error analysis with mortar non-compatible case. Seems they use normal fluxes accros
fracture instead of pressure traces. This allows conforming discretization and error results.

\cite{reichenberger_mixed-dimensional_2006} Finite volume method, fully implicit two phase flow. Cite usage of FRAC3D generator. 

\cite{sladkova_bakalarka} Space-time DG with adaptive mesh, need integration of product of functions on different meshes (in 2D). An algorithm 
for computing triangle-triangle intersections in 2D.

\cite{pichot_generalized_2012} DFN + MHFEM. Mortar method for intersections. Focused on formulation not on intersections. 

\cite{flemisch_non-matching_2012} (Barbara) Mortad, non=matching, acustics. Theory, structured gird case. No complex intersections.

\cite{mustapha_hybrid_2014} Patent for curiosity.

\cite{mittal_immersed_2005} Immersed boundary. ??

\cite{owen_survey_1998} ??

\cite{kuznetsov_overlapping_1998}

\cite{platis_fast_2003} Original algorithm for line-thetrahedra intersections.

\cite{haines_fast_1991} Line-convex Polyhedra intersections using generalisation of line-clipping algorithm


USED:
\cite{massing_efficient_2013} - Implementation of the Nitche method in Fenics. They need 2d-3d intersections, but only for distribution od quadrature points. 
So they do not store whole intersection data, but only the quad points. The boundary of one domain is partitioned into intersections with elements of the other domain.
Use {\\emph collision relations} ( pairs of faces of boundary and elmements of the background mesh) and {\emph collision maps} 
( map face to all intersections and background element to all intersections, can be constructed from the collision relation), They cite books from computer graphics ..
Mention geometric predicates. Present algorithms for:  find intersection candidates, comput intersections, integrate over complex domains.

\cite{elsheikh_reliable_2012} Claim to provide robust algorithm covering all tiangle-trinagle degenerate cases. Basic idea is the same as our: use some tree 
(Binary SPace Tree) structure to find initial point on intersection curve and trace the curve in both directions. Quite clever data structure for the mesh. Adaptive precision 
geometric predicates. Store topological information about the intersection corners (point on triangle, edge, vertex). Resolve various degenerate cases, 
dicuss mesh optimization after subdivision.


\cite{gander_algorithm_2013} Full algorithm for 2d=3D called PANG. Implemented in DUNE in 2010 (Bastian). Other software (Hecht, MpCCI). 
Triangle-Triangle and Tetra-Triangle intersections done similarly as in aur approach: set of points including vertices and then sort them countercolckwise.
Local intersection algorithm do not provide neighbouring information so the traversal algorithm do not use it.

Review of algorithms: \cite{gander_algorithm_2009}


\cite{bournival_mesh-geometry_2008} Application of mixed-dimensional approach in mechanics. Beam and shell elements ...




%\endinput
%%
%% End of file `elsarticle-template-harv.tex'.

-